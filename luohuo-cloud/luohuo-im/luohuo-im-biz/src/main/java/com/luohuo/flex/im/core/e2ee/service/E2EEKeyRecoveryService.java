package com.luohuo.flex.im.core.e2ee.service;

import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;
import com.baomidou.mybatisplus.core.metadata.IPage;
import com.baomidou.mybatisplus.extension.plugins.pagination.Page;
import com.luohuo.basic.exception.BizException;
import com.luohuo.basic.context.ContextUtil;
import com.luohuo.flex.im.core.e2ee.mapper.KeyBackupMapper;
import com.luohuo.flex.im.core.e2ee.mapper.KeyRecoveryRequestMapper;
import com.luohuo.flex.im.domain.dto.*;
import com.luohuo.flex.im.domain.entity.KeyBackup;
import com.luohuo.flex.im.domain.entity.KeyRecoveryRequest;
import com.luohuo.flex.im.domain.entity.UserPublicKey;
import com.luohuo.flex.im.domain.enums.RecoveryStatus;
import com.luohuo.flex.im.domain.enums.RecoveryType;
import com.luohuo.flex.im.domain.vo.KeyRecoveryRequestVO;
import com.luohuo.flex.im.domain.vo.KeyRecoveryDataVO;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.BeanUtils;
import org.springframework.cache.annotation.CacheEvict;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.scheduling.annotation.Async;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.security.SecureRandom;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.Base64;
import java.util.List;
import java.util.Map;
import java.util.concurrent.TimeUnit;

/**
 * E2EE密钥恢复服务
 *
 * @author HuLa Team
 * @since 2025-01-01
 */
@Slf4j
@Service
@RequiredArgsConstructor
public class E2EEKeyRecoveryService {

    private final KeyRecoveryRequestMapper recoveryRequestMapper;
    private final KeyBackupMapper keyBackupMapper;
    private final E2EEKeyService e2eeKeyService;
    private final E2EEAuditService auditService;
    private final StringRedisTemplate redisTemplate;

    private static final String RECOVERY_TOKEN_PREFIX = "e2ee:recovery:token:";
    private static final String ATTEMPT_PREFIX = "e2ee:recovery:attempt:";
    private static final int TOKEN_EXPIRE_HOURS = 24;
    private static final int MAX_ATTEMPTS_PER_HOUR = 5;

    /**
     * 创建密钥恢复请求
     */
    @Transactional(rollbackFor = Exception.class)
    public KeyRecoveryRequestVO createRecoveryRequest(CreateKeyRecoveryDTO dto) {
        log.info("用户 {} 创建密钥恢复请求，密钥ID: {}", ContextUtil.getUserId(), dto.getKeyId());

        // 1. 验证用户身份
        validateUserIdentity(dto);

        // 2. 检查是否有正在进行的恢复请求
        KeyRecoveryRequest existingRequest = recoveryRequestMapper.selectByUserIdAndKeyId(
            ContextUtil.getUserId(), dto.getKeyId()
        );
        if (existingRequest != null && !existingRequest.getStatus().isFinal()) {
            throw new BizException("该密钥已有正在进行的恢复请求");
        }

        // 3. 查找密钥备份
        KeyBackup backup = keyBackupMapper.selectByUserIdAndKeyId(ContextUtil.getUserId(), dto.getKeyId());
        if (backup == null) {
            throw new BizException("未找到密钥备份");
        }

        // 4. 创建恢复请求
        KeyRecoveryRequest request = new KeyRecoveryRequest();
        BeanUtils.copyProperties(dto, request);
        // ID will be auto-generated by MyBatis-Plus with @TableId(type = IdType.ASSIGN_ID)
        request.setUserId(ContextUtil.getUserId());
        request.setTenantId(ContextUtil.getTenantId());
        request.setStatus(RecoveryStatus.PENDING_VERIFICATION);
        request.setVerificationAttempts(0);
        request.setMaxAttempts(dto.getMaxAttempts() != null ? dto.getMaxAttempts() : 3);

        // 生成恢复令牌
        String recoveryToken = generateRecoveryToken();
        request.setRecoveryToken(recoveryToken);
        request.setTokenExpiresAt(LocalDateTime.now().plusHours(TOKEN_EXPIRE_HOURS));

        // 处理安全问答
        if (dto.getSecurityAnswer() != null && !dto.getSecurityAnswer().isEmpty()) {
            String answerHash = hashSecurityAnswer(dto.getSecurityAnswer());
            request.setSecurityAnswerHash(answerHash);
        }

        // 保存请求
        int affectedRows = recoveryRequestMapper.insert(request);
        if (affectedRows <= 0) {
            throw new BizException("创建恢复请求失败");
        }

        // 5. 记录审计日志
        auditService.logSecurityEvent(
            "KEY_RECOVERY_REQUEST",
            "MEDIUM",
            String.format("用户请求恢复密钥: %s", dto.getKeyId()),
            Map.of(
                "requestId", request.getId(),
                "recoveryType", dto.getRecoveryType().name(),
                "backupType", backup.getBackupType()
            )
        );

        // 6. 发送通知
        sendRecoveryNotification(request, dto);

        log.info("密钥恢复请求创建成功，请求ID: {}", request.getId());
        return convertToVO(request);
    }

    /**
     * 验证恢复请求
     */
    @Transactional(rollbackFor = Exception.class)
    public KeyRecoveryRequestVO verifyRecoveryRequest(VerifyRecoveryDTO dto) {
        log.info("验证恢复请求，令牌: {}", dto.getRecoveryToken());

        // 1. 查找恢复请求
        KeyRecoveryRequest request = recoveryRequestMapper.selectByRecoveryToken(dto.getRecoveryToken());
        if (request == null) {
            auditService.logAccessViolation(
                ContextUtil.getUserId(),
                "recovery_token",
                "INVALID_TOKEN"
            );
            throw new BizException("无效的恢复令牌");
        }

        // 2. 检查令牌有效性
        if (!request.isTokenValid()) {
            request.setStatus(RecoveryStatus.EXPIRED);
            recoveryRequestMapper.updateById(request);
            throw new BizException("恢复令牌已过期");
        }

        // 3. 检查验证次数限制
        if (request.isMaxAttemptsReached()) {
            request.setStatus(RecoveryStatus.FAILED);
            request.setFailureReason("超过最大验证次数");
            recoveryRequestMapper.updateById(request);
            throw new BizException("验证次数超过限制");
        }

        // 4. 检查小时尝试次数
        String attemptKey = ATTEMPT_PREFIX + request.getUserId();
        String attempts = redisTemplate.opsForValue().get(attemptKey);
        if (attempts != null && Integer.parseInt(attempts) >= MAX_ATTEMPTS_PER_HOUR) {
            throw new BizException("尝试次数过于频繁，请稍后再试");
        }

        // 5. 验证安全问答
        if (request.getSecurityAnswerHash() != null) {
            if (dto.getSecurityAnswer() == null || dto.getSecurityAnswer().isEmpty()) {
                throw new BizException("需要回答安全问题");
            }

            String answerHash = hashSecurityAnswer(dto.getSecurityAnswer());
            if (!answerHash.equals(request.getSecurityAnswerHash())) {
                // 增加尝试次数
                recoveryRequestMapper.incrementVerificationAttempts(request.getId());
                updateAttemptCount(request.getUserId());

                auditService.logAccessViolation(
                    request.getUserId(),
                    "security_question",
                    "WRONG_ANSWER"
                );

                throw new BizException("安全问题答案错误");
            }
        }

        // 6. 验证成功，更新状态
        request.setStatus(RecoveryStatus.APPROVED);
        request.setReviewedAt(LocalDateTime.now());
        recoveryRequestMapper.updateById(request);

        // 7. 清除尝试计数
        redisTemplate.delete(attemptKey);

        // 8. 记录审计日志
        auditService.logSecurityEvent(
            "KEY_RECOVERY_VERIFIED",
            "HIGH",
            String.format("密钥恢复验证成功: %s", request.getKeyId()),
            Map.of(
                "requestId", request.getId(),
                "userId", request.getUserId()
            )
        );

        log.info("恢复请求验证成功，请求ID: {}", request.getId());
        return convertToVO(request);
    }

    /**
     * 执行密钥恢复
     */
    @Transactional(rollbackFor = Exception.class)
    public KeyRecoveryDataVO recoverKey(RecoverKeyDTO dto) {
        log.info("执行密钥恢复，请求ID: {}", dto.getRequestId());

        // 1. 验证恢复请求
        KeyRecoveryRequest request = recoveryRequestMapper.selectById(dto.getRequestId());
        if (request == null) {
            throw new BizException("恢复请求不存在");
        }

        if (!request.isApproved()) {
            throw new BizException("恢复请求未获批准");
        }

        if (!request.getUserId().equals(ContextUtil.getUserId())) {
            auditService.logAccessViolation(
                ContextUtil.getUserId(),
                "recovery_request",
                "UNAUTHORIZED_ACCESS"
            );
            throw new BizException("无权访问此恢复请求");
        }

        // 2. 查找密钥备份
        KeyBackup backup = keyBackupMapper.selectByUserIdAndKeyId(request.getUserId(), request.getKeyId());
        if (backup == null) {
            throw new BizException("未找到密钥备份");
        }

        // 3. 验证访问代码（如果需要）
        if (backup.getAccessCode() != null) {
            if (dto.getAccessCode() == null || dto.getAccessCode().isEmpty()) {
                throw new BizException("需要提供访问代码");
            }

            String codeHash = hashAccessCode(dto.getAccessCode());
            if (!codeHash.equals(backup.getAccessCode())) {
                auditService.logAccessViolation(
                    request.getUserId(),
                    "backup_access_code",
                    "WRONG_CODE"
                );
                throw new BizException("访问代码错误");
            }
        }

        // 4. 恢复密钥数据
        String recoveredKeyData = decryptBackupData(backup, dto.getRecoveryPassword());

        // 5. 更新请求状态
        request.setStatus(RecoveryStatus.COMPLETED);
        request.setCompletedAt(LocalDateTime.now());
        request.setRecoveredKeyData(encryptRecoveredData(recoveredKeyData, dto.getRecoveryPassword()));
        recoveryRequestMapper.updateById(request);

        // 6. 更新备份访问记录
        keyBackupMapper.updateLastAccessed(backup.getUserId(), backup.getKeyId());

        // 7. 记录审计日志
        auditService.logSecurityEvent(
            "KEY_RECOVERY_COMPLETED",
            "CRITICAL",
            String.format("密钥恢复完成: %s", request.getKeyId()),
            Map.of(
                "requestId", request.getId(),
                "userId", request.getUserId(),
                "backupType", backup.getBackupType()
            )
        );

        // 8. 返回恢复数据
        KeyRecoveryDataVO response = new KeyRecoveryDataVO();
        response.setKeyId(request.getKeyId());
        response.setAlgorithm(recoveredKeyData.contains("RSA") ? "RSA" : "EC");
        response.setPublicKeyData(recoveredKeyData);
        response.setRecoveryTime(LocalDateTime.now());

        log.info("密钥恢复完成，请求ID: {}", request.getId());
        return response;
    }

    /**
     * 查询用户的恢复请求
     */
    public IPage<KeyRecoveryRequestVO> getUserRecoveryRequests(int page, int size, String keyId) {
        Page<KeyRecoveryRequest> pageInfo = new Page<>(page, size);
        IPage<KeyRecoveryRequest> result = recoveryRequestMapper.selectUserRecoveryHistory(
            pageInfo, ContextUtil.getUserId(), keyId
        );

        return result.convert(this::convertToVO);
    }

    /**
     * 管理员查询待审核的恢复请求
     */
    public IPage<KeyRecoveryRequestVO> getPendingRecoveryRequests(int page, int size, String recoveryType) {
        Page<KeyRecoveryRequest> pageInfo = new Page<>(page, size);
        RecoveryType type = recoveryType != null ? RecoveryType.fromCode(recoveryType) : null;

        IPage<KeyRecoveryRequest> result = recoveryRequestMapper.selectPendingRequests(
            pageInfo, ContextUtil.getTenantId(), type
        );

        return result.convert(this::convertToVO);
    }

    /**
     * 审核恢复请求
     */
    @Transactional(rollbackFor = Exception.class)
    public void reviewRecoveryRequest(Long requestId, ReviewRecoveryDTO dto) {
        KeyRecoveryRequest request = recoveryRequestMapper.selectById(requestId);
        if (request == null) {
            throw new BizException("恢复请求不存在");
        }

        if (!request.isPending() && !request.isPendingVerification()) {
            throw new BizException("请求状态不允许审核");
        }

        // 更新审核信息
        recoveryRequestMapper.updateStatus(
            requestId,
            dto.getApproved() ? RecoveryStatus.APPROVED : RecoveryStatus.REJECTED,
            ContextUtil.getUserId(),
            dto.getComment()
        );

        // 记录审计日志
        auditService.logSecurityEvent(
            dto.getApproved() ? "KEY_RECOVERY_APPROVED" : "KEY_RECOVERY_REJECTED",
            "HIGH",
            String.format("管理员审核恢复请求: %s", request.getKeyId()),
            Map.of(
                "requestId", requestId,
                "reviewerId", ContextUtil.getUserId(),
                "comment", dto.getComment()
            )
        );
    }

    /**
     * 定时清理过期的恢复请求
     */
    @Scheduled(cron = "0 0 * * * ?") // 每小时执行
    @Async("e2eeCleanupExecutor")
    public void cleanupExpiredRequests() {
        log.debug("开始清理过期的恢复请求");

        LocalDateTime now = LocalDateTime.now();
        List<KeyRecoveryRequest> expiredRequests = recoveryRequestMapper.selectExpiredRequests(now);

        if (!expiredRequests.isEmpty()) {
            List<Long> ids = expiredRequests.stream()
                .map(KeyRecoveryRequest::getId)
                .toList();

            int updatedCount = recoveryRequestMapper.batchUpdateExpiredStatus(
                ids, RecoveryStatus.EXPIRED
            );

            log.info("清理过期恢复请求 {} 个", updatedCount);
            // 记录指标（E2EEMetrics已实现）
            // 注意：可在此处记录密钥恢复相关指标
            // e2eeMetrics.recordKeyRecoveryRequest(recoveryType);
            // e2eeMetrics.recordCleanupOperation("recovery_requests", updatedCount);
        }
    }

    // 私有方法

    private void validateUserIdentity(CreateKeyRecoveryDTO dto) {
        // 实现用户身份验证逻辑
        // 可以通过密码验证、短信验证、邮箱验证等方式
    }

    private String generateRecoveryToken() {
        SecureRandom random = new SecureRandom();
        byte[] bytes = new byte[32];
        random.nextBytes(bytes);
        return Base64.getUrlEncoder().withoutPadding().encodeToString(bytes);
    }

    private String hashSecurityAnswer(String answer) {
        try {
            MessageDigest digest = MessageDigest.getInstance("SHA-256");
            byte[] hash = digest.digest(answer.toLowerCase().trim().getBytes(StandardCharsets.UTF_8));
            return Base64.getEncoder().encodeToString(hash);
        } catch (Exception e) {
            throw new BizException("哈希计算失败");
        }
    }

    private String hashAccessCode(String code) {
        try {
            MessageDigest digest = MessageDigest.getInstance("SHA-256");
            byte[] hash = digest.digest(code.getBytes(StandardCharsets.UTF_8));
            return Base64.getEncoder().encodeToString(hash);
        } catch (Exception e) {
            throw new BizException("访问代码哈希计算失败");
        }
    }

    private void updateAttemptCount(Long userId) {
        String key = ATTEMPT_PREFIX + userId;
        String attempts = redisTemplate.opsForValue().get(key);
        int count = attempts != null ? Integer.parseInt(attempts) : 0;
        count++;

        redisTemplate.opsForValue().set(key, String.valueOf(count), 1, TimeUnit.HOURS);
    }

    private void sendRecoveryNotification(KeyRecoveryRequest request, CreateKeyRecoveryDTO dto) {
        // 发送恢复通知（邮件、短信等）
        // 这里可以集成消息推送服务
    }

    private String decryptBackupData(KeyBackup backup, String password) {
        // 实现备份数据解密逻辑
        // 根据不同的备份类型使用不同的解密方案
        return "decrypted_key_data_placeholder";
    }

    private String encryptRecoveredData(String data, String password) {
        // 加密恢复的数据以便存储
        return "encrypted_recovered_data_placeholder";
    }

    private KeyRecoveryRequestVO convertToVO(KeyRecoveryRequest request) {
        KeyRecoveryRequestVO vo = new KeyRecoveryRequestVO();
        BeanUtils.copyProperties(request, vo);
        // 隐藏敏感信息
        vo.setRecoveryToken(null);
        vo.setSecurityAnswerHash(null);
        vo.setBackupVerification(null);
        vo.setRecoveredKeyData(null);
        return vo;
    }
}