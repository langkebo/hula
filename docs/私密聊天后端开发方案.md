# 私密聊天后端开发方案

## 一、项目概述

### 1.1 背景与目标
私密聊天模块是HuLa即时通讯系统的核心功能之一，旨在为用户提供端到端加密的安全通讯能力。该方案确保只有通信双方能够解密和阅读消息内容，即使是服务器管理员也无法获取明文消息。

### 1.2 核心特性
- **端到端加密（E2EE）**：基于RSA-2048和AES-256-GCM算法
- **前向安全**：支持临时密钥对，定期轮换会话密钥
- **身份认证**：基于RSA-PSS的数字签名
- **密钥管理**：完整的密钥生命周期管理
- **安全审计**：所有加密操作的完整日志记录

### 1.3 技术栈
- **框架**：Spring Boot 3.x + Spring WebFlux
- **数据库**：MySQL 8.0+（持久化） + Redis 6.0+（缓存）
- **消息队列**：Apache RocketMQ 5.x
- **加密库**：Java Cryptography Extension (JCE)
- **协议**：WebSocket + HTTP/2

## 二、系统架构设计

### 2.1 整体架构
```
┌─────────────────────────────────────────────────────────────┐
│                        私密聊天系统                           │
├─────────────────────────────────────────────────────────────┤
│  ┌───────────────┐  ┌───────────────┐  ┌─────────────────┐  │
│  │   密钥管理     │  │   消息加密     │  │   安全审计       │  │
│  │   服务        │  │   服务        │  │   服务          │  │
│  └───────────────┘  └───────────────┘  └─────────────────┘  │
│         │                   │                   │          │
│  ┌─────────────────────────────────────────────────────────┐  │
│  │              E2EE核心服务层                              │  │
│  └─────────────────────────────────────────────────────────┘  │
│         │                   │                   │          │
│  ┌───────────────┐  ┌───────────────┐  ┌─────────────────┐  │
│  │  HTTP API     │  │  WebSocket    │  │   消息队列       │  │
│  │  接口层       │  │  实时通信      │  │  异步处理       │  │
│  └───────────────┘  └───────────────┘  └─────────────────┘  │
└─────────────────────────────────────────────────────────────┘
```

### 2.2 模块划分
1. **e2ee-core**：核心加密功能模块
2. **e2ee-key**：密钥管理模块
3. **e2ee-message**：加密消息处理模块
4. **e2ee-audit**：安全审计模块
5. **e2ee-api**：对外接口模块

### 2.3 部署架构
```
┌───────────────┐     ┌───────────────┐     ┌───────────────┐
│   Load        │     │   E2EE        │     │   RocketMQ    │
│   Balancer    │────▶│   Service     │────▶│   Cluster     │
└───────────────┘     └───────────────┘     └───────────────┘
                              │
                              ▼
                       ┌───────────────┐
                       │   MySQL       │
                       │   Cluster     │
                       └───────────────┘
                              │
                              ▼
                       ┌───────────────┐
                       │   Redis       │
                       │   Cluster     │
                       └───────────────┘
```

## 三、数据库设计

### 3.1 核心表结构

#### 3.1.1 用户公钥表（im_user_public_key）
```sql
CREATE TABLE im_user_public_key (
    id BIGINT PRIMARY KEY AUTO_INCREMENT COMMENT '主键ID',
    user_id BIGINT NOT NULL COMMENT '用户ID',
    key_id VARCHAR(64) NOT NULL COMMENT '密钥唯一标识',
    spki TEXT NOT NULL COMMENT '公钥SPKI数据(Base64)',
    algorithm VARCHAR(32) NOT NULL DEFAULT 'RSA-OAEP' COMMENT '加密算法',
    fingerprint CHAR(64) NOT NULL COMMENT 'SHA-256指纹',
    status TINYINT NOT NULL DEFAULT 1 COMMENT '状态:1-有效,0-已撤销',
    create_time DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    update_time DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
    tenant_id BIGINT NOT NULL COMMENT '租户ID',
    INDEX idx_user_id (user_id),
    INDEX idx_key_id (key_id),
    INDEX idx_fingerprint (fingerprint),
    UNIQUE KEY uk_user_key (user_id, key_id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='用户公钥表';
```

#### 3.1.2 会话密钥包表（im_session_key_package）
```sql
CREATE TABLE im_session_key_package (
    id BIGINT PRIMARY KEY AUTO_INCREMENT COMMENT '主键ID',
    session_id VARCHAR(64) NOT NULL COMMENT '会话标识',
    key_id VARCHAR(64) NOT NULL COMMENT '密钥ID',
    sender_id BIGINT NOT NULL COMMENT '发送者ID',
    recipient_id BIGINT NOT NULL COMMENT '接收者ID',
    wrapped_key TEXT NOT NULL COMMENT '包装后的会话密钥(Base64)',
    algorithm VARCHAR(32) NOT NULL DEFAULT 'AES-GCM' COMMENT '对称加密算法',
    expires_at DATETIME NOT NULL COMMENT '过期时间',
    status TINYINT NOT NULL DEFAULT 1 COMMENT '状态:1-有效,0-已撤销',
    create_time DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    tenant_id BIGINT NOT NULL COMMENT '租户ID',
    INDEX idx_session (session_id),
    INDEX idx_recipient (recipient_id),
    INDEX idx_expires (expires_at)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='会话密钥包表';
```

#### 3.1.3 加密消息表（im_encrypted_message）
```sql
CREATE TABLE im_encrypted_message (
    id BIGINT PRIMARY KEY AUTO_INCREMENT COMMENT '主键ID',
    message_id BIGINT NOT NULL COMMENT '关联的消息ID',
    conversation_id VARCHAR(64) NOT NULL COMMENT '会话ID',
    sender_id BIGINT NOT NULL COMMENT '发送者ID',
    key_id VARCHAR(64) NOT NULL COMMENT '使用的密钥ID',
    ciphertext MEDIUMTEXT NOT NULL COMMENT '加密后的消息内容(Base64)',
    iv VARCHAR(32) NOT NULL COMMENT '初始化向量(Base64)',
    tag VARCHAR(32) NOT NULL COMMENT '认证标签(Base64)',
    content_hash CHAR(64) NOT NULL COMMENT '内容哈希(SHA-256)',
    signature TEXT COMMENT '数字签名(Base64)',
    signature_key_id VARCHAR(64) COMMENT '签名密钥ID',
    create_time DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    tenant_id BIGINT NOT NULL COMMENT '租户ID',
    INDEX idx_message (message_id),
    INDEX idx_conversation (conversation_id),
    INDEX idx_sender (sender_id),
    INDEX idx_create_time (create_time)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='加密消息表';
```

#### 3.1.4 密钥操作审计表（im_key_audit_log）
```sql
CREATE TABLE im_key_audit_log (
    id BIGINT PRIMARY KEY AUTO_INCREMENT COMMENT '主键ID',
    user_id BIGINT NOT NULL COMMENT '操作用户ID',
    operation_type VARCHAR(32) NOT NULL COMMENT '操作类型',
    target_key_id VARCHAR(64) COMMENT '目标密钥ID',
    operation_result VARCHAR(16) NOT NULL COMMENT '操作结果:SUCCESS/FAILED',
    error_message TEXT COMMENT '错误信息',
    client_ip VARCHAR(64) NOT NULL COMMENT '客户端IP',
    user_agent TEXT COMMENT '用户代理',
    operation_time DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '操作时间',
    extra_data JSON COMMENT '额外数据',
    tenant_id BIGINT NOT NULL COMMENT '租户ID',
    INDEX idx_user_time (user_id, operation_time),
    INDEX idx_operation (operation_type),
    INDEX idx_time (operation_time)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='密钥操作审计表';
```

### 3.2 索引优化策略
1. **复合索引**：针对高频查询组合创建复合索引
2. **分区表**：对大数据量表按时间进行分区
3. **覆盖索引**：优化常用查询，避免回表

## 四、API接口设计

### 4.1 密钥管理接口

#### 4.1.1 上传公钥
```java
@PostMapping("/e2ee/public-key/upload")
@Operation(summary = "上传用户公钥", description = "用户上传新的RSA公钥用于加密消息")
public R<Void> uploadPublicKey(@RequestBody @Valid UploadPublicKeyDTO dto) {
    // 1. 验证用户身份
    // 2. 验证公钥格式
    // 3. 计算指纹
    // 4. 保存到数据库
    // 5. 记录审计日志
    return R.ok();
}

@Data
public class UploadPublicKeyDTO {
    @NotBlank(message = "密钥ID不能为空")
    private String keyId;

    @NotBlank(message = "公钥数据不能为空")
    private String spki;

    @NotBlank(message = "算法不能为空")
    private String algorithm;

    private Boolean activateOldKeys = false;
}
```

#### 4.1.2 获取用户公钥
```java
@GetMapping("/e2ee/public-key/{userId}")
@Operation(summary = "获取用户公钥", description = "获取指定用户的最新有效公钥")
public R<PublicKeyInfoDTO> getUserPublicKey(
    @PathVariable Long userId,
    @RequestParam(required = false) String keyId) {
    // 1. 验证权限
    // 2. 查询公钥
    // 3. 返回公钥信息
    return R.ok(publicKeyInfo);
}
```

#### 4.1.3 批量获取公钥
```java
@PostMapping("/e2ee/public-key/batch")
@Operation(summary = "批量获取公钥", description = "批量获取多个用户的公钥")
public R<List<PublicKeyInfoDTO>> batchGetPublicKeys(@RequestBody BatchGetPublicKeyDTO dto) {
    // 1. 参数验证
    // 2. 批量查询
    // 3. 返回结果
    return R.ok(publicKeys);
}

@Data
public class BatchGetPublicKeyDTO {
    @NotEmpty(message = "用户ID列表不能为空")
    private List<Long> userIds;
}
```

### 4.2 会话密钥管理接口

#### 4.2.1 分发会话密钥
```java
@PostMapping("/e2ee/session-key/distribute")
@Operation(summary = "分发会话密钥", description = "向接收者分发加密的会话密钥")
public R<Void> distributeSessionKey(@RequestBody @Valid SessionKeyPackageDTO dto) {
    // 1. 验证发送者权限
    // 2. 验证接收者存在
    // 3. 保存密钥包
    // 4. 通知接收者
    // 5. 记录审计
    return R.ok();
}

@Data
public class SessionKeyPackageDTO {
    @NotBlank(message = "会话ID不能为空")
    private String sessionId;

    @NotBlank(message = "密钥ID不能为空")
    private String keyId;

    @NotBlank(message = "包装密钥不能为空")
    private String wrappedKey;

    @NotBlank(message = "算法不能为空")
    private String algorithm;

    @NotNull(message = "接收者ID不能为空")
    private Long recipientId;

    private LocalDateTime expiresAt;
}
```

#### 4.2.2 获取待接收密钥包
```java
@GetMapping("/e2ee/session-key/pending")
@Operation(summary = "获取待接收密钥包", description = "获取当前用户的待接收密钥包列表")
public R<List<SessionKeyPackageDTO>> getPendingKeyPackages() {
    // 1. 获取当前用户ID
    // 2. 查询待接收的密钥包
    // 3. 返回列表
    return R.ok(keyPackages);
}
```

### 4.3 加密消息接口

#### 4.3.1 保存加密消息
```java
@PostMapping("/e2ee/message/save")
@Operation(summary = "保存加密消息", description = "保存端到端加密的消息")
public R<Long> saveEncryptedMessage(@RequestBody @Valid SaveEncryptedMessageDTO dto) {
    // 1. 验证消息格式
    // 2. 计算内容哈希
    // 3. 验证签名（可选）
    // 4. 保存加密数据
    // 5. 返回消息ID
    return R.ok(messageId);
}

@Data
public class SaveEncryptedMessageDTO {
    @NotBlank(message = "会话ID不能为空")
    private String conversationId;

    @NotBlank(message = "密文不能为空")
    private String ciphertext;

    @NotBlank(message = "IV不能为空")
    private String iv;

    @NotBlank(message = "认证标签不能为空")
    private String tag;

    @NotBlank(message = "密钥ID不能为空")
    private String keyId;

    private String signature;

    private String signatureKeyId;
}
```

#### 4.3.2 获取加密消息
```java
@GetMapping("/e2ee/message/{messageId}")
@Operation(summary = "获取加密消息", description = "获取指定消息的加密内容")
public R<EncryptedMessageDTO> getEncryptedMessage(@PathVariable Long messageId) {
    // 1. 验证访问权限
    // 2. 查询加密消息
    // 3. 返回加密数据
    return R.ok(encryptedMessage);
}
```

#### 4.3.3 验证消息签名
```java
@PostMapping("/e2ee/message/verify")
@Operation(summary = "验证消息签名", description = "验证消息的数字签名")
public R<SignatureVerifyResultDTO> verifyMessageSignature(
    @PathVariable Long messageId,
    @RequestBody SignatureVerifyDTO dto) {
    // 1. 获取消息内容
    // 2. 获取签名公钥
    // 3. 执行验证
    // 4. 返回结果
    return R.ok(verifyResult);
}
```

## 五、核心服务实现

### 5.1 密钥管理服务

#### 5.1.1 公钥服务实现
```java
@Service
public class E2EEKeyService {

    @Autowired
    private UserPublicKeyMapper userPublicKeyMapper;

    @Autowired
    private KeyAuditLogMapper keyAuditLogMapper;

    /**
     * 保存用户公钥
     */
    @Transactional
    public void saveUserPublicKey(UploadPublicKeyDTO dto, Long userId) {
        // 1. 验证公钥格式
        PublicKeyInfo publicKeyInfo = validateAndParsePublicKey(dto);

        // 2. 检查密钥是否已存在
        UserPublicKey existingKey = userPublicKeyMapper.selectByUserIdAndKeyId(userId, dto.getKeyId());
        if (existingKey != null) {
            throw new BusinessException("密钥已存在");
        }

        // 3. 保存公钥
        UserPublicKey publicKey = new UserPublicKey();
        publicKey.setUserId(userId);
        publicKey.setKeyId(dto.getKeyId());
        publicKey.setSpki(dto.getSpki());
        publicKey.setAlgorithm(dto.getAlgorithm());
        publicKey.setFingerprint(publicKeyInfo.getFingerprint());
        publicKey.setTenantId(SecurityUtils.getTenantId());

        userPublicKeyMapper.insert(publicKey);

        // 4. 如果启用激活旧密钥，撤销旧密钥
        if (dto.getActivateOldKeys()) {
            revokeOldKeys(userId, dto.getKeyId());
        }

        // 5. 记录审计日志
        logKeyOperation(userId, "UPLOAD_PUBLIC_KEY", dto.getKeyId(), "SUCCESS", null);
    }

    /**
     * 获取用户公钥
     */
    public PublicKeyInfoDTO getUserPublicKey(Long userId, String keyId) {
        UserPublicKey publicKey;
        if (StringUtils.hasText(keyId)) {
            publicKey = userPublicKeyMapper.selectByUserIdAndKeyId(userId, keyId);
        } else {
            publicKey = userPublicKeyMapper.selectLatestByUserId(userId);
        }

        if (publicKey == null || publicKey.getStatus() == 0) {
            throw new BusinessException("公钥不存在或已撤销");
        }

        return convertToDTO(publicKey);
    }

    /**
     * 验证和解析公钥
     */
    private PublicKeyInfo validateAndParsePublicKey(UploadPublicKeyDTO dto) {
        try {
            // 1. Base64解码
            byte[] spkiBytes = Base64.getDecoder().decode(dto.getSpki());

            // 2. 生成X509EncodedKeySpec
            X509EncodedKeySpec keySpec = new X509EncodedKeySpec(spkiBytes);

            // 3. 根据算法创建KeyFactory
            KeyFactory keyFactory = KeyFactory.getInstance("RSA");
            PublicKey publicKey = keyFactory.generatePublic(keySpec);

            // 4. 验证密钥长度
            RSA rsaKey = (RSA) publicKey;
            if (rsaKey.getModulus().bitLength() < 2048) {
                throw new BusinessException("RSA密钥长度必须至少2048位");
            }

            // 5. 计算指纹
            MessageDigest digest = MessageDigest.getInstance("SHA-256");
            byte[] fingerprint = digest.digest(spkiBytes);

            return new PublicKeyInfo(
                dto.getKeyId(),
                dto.getSpki(),
                bytesToHex(fingerprint),
                dto.getAlgorithm()
            );

        } catch (Exception e) {
            throw new BusinessException("无效的公钥格式", e);
        }
    }
}
```

#### 5.1.2 会话密钥服务实现
```java
@Service
public class E2EESessionKeyService {

    @Autowired
    private SessionKeyPackageMapper sessionKeyPackageMapper;

    @Autowired
    private RocketMQTemplate rocketMQTemplate;

    /**
     * 分发会话密钥
     */
    @Transactional
    public void distributeSessionKey(SessionKeyPackageDTO dto, Long senderId) {
        // 1. 验证接收者
        UserPublicKey recipientKey = userPublicKeyMapper.selectLatestByUserId(dto.getRecipientId());
        if (recipientKey == null) {
            throw new BusinessException("接收者公钥不存在");
        }

        // 2. 保存密钥包
        SessionKeyPackage keyPackage = new SessionKeyPackage();
        keyPackage.setSessionId(dto.getSessionId());
        keyPackage.setKeyId(dto.getKeyId());
        keyPackage.setSenderId(senderId);
        keyPackage.setRecipientId(dto.getRecipientId());
        keyPackage.setWrappedKey(dto.getWrappedKey());
        keyPackage.setAlgorithm(dto.getAlgorithm());
        keyPackage.setExpiresAt(dto.getExpiresAt());
        keyPackage.setTenantId(SecurityUtils.getTenantId());

        sessionKeyPackageMapper.insert(keyPackage);

        // 3. 撤销旧的会话密钥
        revokeOldSessionKeys(dto.getSessionId(), dto.getRecipientId());

        // 4. 发送通知消息
        notifyRecipientKeyPackage(dto.getRecipientId(), dto);

        // 5. 记录审计日志
        logKeyOperation(senderId, "DISTRIBUTE_SESSION_KEY", dto.getKeyId(), "SUCCESS", null);
    }

    /**
     * 获取待接收密钥包
     */
    public List<SessionKeyPackageDTO> getPendingKeyPackages(Long userId) {
        List<SessionKeyPackage> packages = sessionKeyPackageMapper.selectPendingByRecipientId(userId);

        return packages.stream()
            .map(this::convertToDTO)
            .collect(Collectors.toList());
    }
}
```

### 5.2 加密消息服务

#### 5.2.1 消息加密存储服务
```java
@Service
public class E2EEMessageService {

    @Autowired
    private EncryptedMessageMapper encryptedMessageMapper;

    @Autowired
    private MessageMapper messageMapper;

    /**
     * 保存加密消息
     */
    @Transactional
    public Long saveEncryptedMessage(SaveEncryptedMessageDTO dto, Long senderId) {
        // 1. 计算内容哈希
        String contentHash = calculateContentHash(dto);

        // 2. 验证签名（如果提供）
        if (dto.getSignature() != null) {
            verifySignature(dto, senderId);
        }

        // 3. 创建消息记录
        Message message = new Message();
        message.setRoomId(getRoomIdFromConversationId(dto.getConversationId()));
        message.setFromUid(senderId);
        message.setType(MessageTypeEnum.ENCRYPTED.getCode());
        message.setIsEncrypted(true);
        message.setStatus(MessageStatusEnum.SENT.getCode());
        message.setTenantId(SecurityUtils.getTenantId());

        messageMapper.insert(message);

        // 4. 保存加密内容
        EncryptedMessage encrypted = new EncryptedMessage();
        encrypted.setMessageId(message.getId());
        encrypted.setConversationId(dto.getConversationId());
        encrypted.setSenderId(senderId);
        encrypted.setKeyId(dto.getKeyId());
        encrypted.setCiphertext(dto.getCiphertext());
        encrypted.setIv(dto.getIv());
        encrypted.setTag(dto.getTag());
        encrypted.setContentHash(contentHash);
        encrypted.setSignature(dto.getSignature());
        encrypted.setSignatureKeyId(dto.getSignatureKeyId());
        encrypted.setTenantId(SecurityUtils.getTenantId());

        encryptedMessageMapper.insert(encrypted);

        // 5. 发布消息事件
        publishMessageEvent(message, encrypted);

        return message.getId();
    }

    /**
     * 获取加密消息
     */
    public EncryptedMessageDTO getEncryptedMessage(Long messageId, Long userId) {
        // 1. 验证访问权限
        Message message = messageMapper.selectById(messageId);
        if (message == null) {
            throw new BusinessException("消息不存在");
        }

        validateMessageAccess(message, userId);

        // 2. 获取加密内容
        EncryptedMessage encrypted = encryptedMessageMapper.selectByMessageId(messageId);
        if (encrypted == null) {
            throw new BusinessException("加密消息不存在");
        }

        return convertToDTO(encrypted);
    }

    /**
     * 计算内容哈希
     */
    private String calculateContentHash(SaveEncryptedMessageDTO dto) {
        try {
            MessageDigest digest = MessageDigest.getInstance("SHA-256");
            String content = dto.getCiphertext() + dto.getIv() + dto.getTag() + dto.getKeyId();
            byte[] hash = digest.digest(content.getBytes(StandardCharsets.UTF_8));
            return bytesToHex(hash);
        } catch (Exception e) {
            throw new BusinessException("计算哈希失败", e);
        }
    }

    /**
     * 验证数字签名
     */
    private void verifySignature(SaveEncryptedMessageDTO dto, Long senderId) {
        try {
            // 1. 获取签名公钥
            UserPublicKey publicKey = userPublicKeyMapper.selectByUserIdAndKeyId(
                senderId, dto.getSignatureKeyId()
            );

            if (publicKey == null) {
                throw new BusinessException("签名公钥不存在");
            }

            // 2. 解码公钥
            byte[] spkiBytes = Base64.getDecoder().decode(publicKey.getSpki());
            X509EncodedKeySpec keySpec = new X509EncodedKeySpec(spkiBytes);
            KeyFactory keyFactory = KeyFactory.getInstance("RSA");
            PublicKey verifyKey = keyFactory.generatePublic(keySpec);

            // 3. 准备待签名数据
            String signedData = dto.getCiphertext() + dto.getIv() + dto.getTag();
            byte[] dataBytes = signedData.getBytes(StandardCharsets.UTF_8);

            // 4. 解码签名
            byte[] signatureBytes = Base64.getDecoder().decode(dto.getSignature());

            // 5. 验证签名
            Signature signature = Signature.getInstance("SHA256withRSA");
            signature.initVerify(verifyKey);
            signature.update(dataBytes);

            if (!signature.verify(signatureBytes)) {
                throw new BusinessException("数字签名验证失败");
            }

        } catch (Exception e) {
            throw new BusinessException("签名验证异常", e);
        }
    }
}
```

### 5.3 安全审计服务

#### 5.3.1 审计日志服务
```java
@Service
public class E2EEAuditService {

    @Autowired
    private KeyAuditLogMapper keyAuditLogMapper;

    /**
     * 记录密钥操作日志
     */
    @Async
    public void logKeyOperation(
        Long userId,
        String operationType,
        String targetKeyId,
        String result,
        String errorMessage) {

        KeyAuditLog log = new KeyAuditLog();
        log.setUserId(userId);
        log.setOperationType(operationType);
        log.setTargetKeyId(targetKeyId);
        log.setOperationResult(result);
        log.setErrorMessage(errorMessage);
        log.setClientIp(ServletUtils.getClientIP());
        log.setUserAgent(ServletUtils.getUserAgent());
        log.setTenantId(SecurityUtils.getTenantId());

        keyAuditLogMapper.insert(log);
    }

    /**
     * 查询审计日志
     */
    public PageResult<KeyAuditLogDTO> queryAuditLogs(KeyAuditQueryDTO query) {
        // 1. 构建查询条件
        LambdaQueryWrapper<KeyAuditLog> wrapper = new LambdaQueryWrapper<>();
        wrapper.eq(query.getUserId() != null, KeyAuditLog::getUserId, query.getUserId())
                .eq(StringUtils.hasText(query.getOperationType()), KeyAuditLog::getOperationType, query.getOperationType())
                .eq(StringUtils.hasText(query.getOperationResult()), KeyAuditLog::getOperationResult, query.getOperationResult())
                .between(query.getStartTime() != null && query.getEndTime() != null,
                        KeyAuditLog::getOperationTime, query.getStartTime(), query.getEndTime())
                .orderByDesc(KeyAuditLog::getOperationTime);

        // 2. 分页查询
        Page<KeyAuditLog> page = keyAuditLogMapper.selectPage(
            new Page<>(query.getPageNum(), query.getPageSize()),
            wrapper
        );

        // 3. 转换结果
        List<KeyAuditLogDTO> list = page.getRecords().stream()
            .map(this::convertToDTO)
            .collect(Collectors.toList());

        return new PageResult<>(list, page.getTotal());
    }
}
```

## 六、安全机制

### 6.1 加密算法选择
1. **非对称加密**：RSA-OAEP with SHA-256
   - 密钥长度：2048位（最低）至4096位（推荐）
   - 填充方案：OAEP
   - 哈希函数：SHA-256

2. **对称加密**：AES-GCM
   - 密钥长度：256位
   - IV长度：96位（12字节）
   - 认证标签：128位（16字节）

3. **数字签名**：RSA-PSS
   - 密钥长度：2048位（最低）
   - 盐值长度：32字节
   - 哈希函数：SHA-256

### 6.2 密钥生命周期管理

#### 6.2.1 密钥生成
```java
@Component
public class KeyGenerator {

    /**
     * 生成RSA密钥对
     */
    public KeyPair generateRSAKeyPair(int keySize) throws Exception {
        KeyPairGenerator keyGen = KeyPairGenerator.getInstance("RSA");
        keyGen.initialize(keySize, new SecureRandom());
        return keyGen.generateKeyPair();
    }

    /**
     * 生成AES会话密钥
     */
    public SecretKey generateAESKey() throws Exception {
        KeyGenerator keyGen = KeyGenerator.getInstance("AES");
        keyGen.init(256, new SecureRandom());
        return keyGen.generateKey();
    }

    /**
     * 生成随机IV
     */
    public byte[] generateIV() {
        byte[] iv = new byte[12];
        new SecureRandom().nextBytes(iv);
        return iv;
    }
}
```

#### 6.2.2 密钥轮换策略
1. **定期轮换**：每365天更换主密钥对
2. **会话密钥**：每24小时或每1000条消息更换
3. **临时密钥**：每次会话生成新的临时密钥对
4. **前向安全**：使用Diffie-Hellman密钥交换

### 6.3 安全防护措施

#### 6.3.1 防重放攻击
```java
@Component
public class ReplayAttackProtection {

    private final Map<String, Set<String>> nonces = new ConcurrentHashMap<>();

    /**
     * 检查nonce是否已使用
     */
    public boolean isNonceUsed(String userId, String nonce) {
        Set<String> userNonces = nonces.computeIfAbsent(userId, k -> ConcurrentHashMap.newKeySet());
        return !userNonces.add(nonce);
    }

    /**
     * 清理过期的nonce
     */
    @Scheduled(fixedDelay = 300000) // 5分钟执行一次
    public void cleanExpiredNonces() {
        // 实现nonce清理逻辑
    }
}
```

#### 6.3.2 限流控制
```java
@Component
public class E2EERateLimiter {

    private final RateLimiter uploadKeyLimiter = RateLimiter.create(5.0); // 每秒5次
    private final RateLimiter messageLimiter = RateLimiter.create(100.0); // 每秒100次

    /**
     * 检查上传密钥限流
     */
    public boolean tryAcquireUploadKey() {
        return uploadKeyLimiter.tryAcquire();
    }

    /**
     * 检查发送消息限流
     */
    public boolean tryAcquireSendMessage() {
        return messageLimiter.tryAcquire();
    }
}
```

## 七、性能优化

### 7.1 缓存策略
1. **Redis缓存**：
   - 用户公钥缓存（TTL: 1小时）
   - 会话密钥缓存（TTL: 24小时）
   - 频繁查询的加密消息缓存（TTL: 30分钟）

2. **本地缓存**：
   - Caffeine缓存热点数据
   - 缓存大小：10000条
   - 过期时间：5分钟

### 7.2 数据库优化
1. **读写分离**：查询操作使用只读副本
2. **分库分表**：按租户ID进行分库
3. **归档策略**：超过6个月的加密消息归档到冷存储

### 7.3 异步处理
1. **消息发送**：使用RocketMQ异步处理
2. **审计日志**：异步写入，避免影响主流程
3. **密钥分发**：异步通知接收者

## 八、监控与告警

### 8.1 关键指标监控
1. **加密/解密性能**：操作耗时统计
2. **密钥使用情况**：密钥分布和轮换情况
3. **错误率**：加密失败、签名验证失败率
4. **吞吐量**：每秒处理的消息数

### 8.2 告警规则
1. **加密操作延迟超过100ms**
2. **密钥验证失败率超过1%**
3. **未授权的密钥操作尝试**
4. **密钥即将过期（30天内）**

## 九、部署方案

### 9.1 环境要求
- **Java**：JDK 21+
- **Spring Boot**：3.2.x
- **MySQL**：8.0+
- **Redis**：6.0+
- **RocketMQ**：5.1.x

### 9.2 部署配置
```yaml
# application-e2ee.yml
e2ee:
  # 加密配置
  crypto:
    rsa:
      key-size: 2048
      algorithm: RSA-OAEP
      hash: SHA-256
    aes:
      key-size: 256
      algorithm: AES-GCM
      iv-length: 12
    signature:
      algorithm: RSA-PSS
      salt-length: 32

  # 密钥轮换配置
  rotation:
    master-key-days: 365
    session-key-hours: 24
    session-key-messages: 1000

  # 缓存配置
  cache:
    public-key-ttl: 3600 # 1小时
    session-key-ttl: 86400 # 24小时
    message-ttl: 1800 # 30分钟

  # 限流配置
  rate-limit:
    upload-key: 5 # 每秒5次
    send-message: 100 # 每秒100次

  # 安全配置
  security:
    max-key-age-days: 400
    nonce-expire-minutes: 5
    audit-log-retention-days: 90
```

### 9.3 容器化部署
```dockerfile
FROM openjdk:21-jre-slim

LABEL maintainer="HuLa Team"
LABEL version="1.0.0"

# 设置时区
ENV TZ=Asia/Shanghai
RUN ln -snf /usr/share/zoneinfo/$TZ /etc/localtime && echo $TZ > /etc/timezone

# 创建应用目录
WORKDIR /app

# 复制jar包
COPY hula-e2ee-service.jar app.jar

# 设置JVM参数
ENV JAVA_OPTS="-Xms2g -Xmx4g -XX:+UseG1GC -XX:MaxGCPauseMillis=200"

# 健康检查
HEALTHCHECK --interval=30s --timeout=10s --start-period=60s --retries=3 \
  CMD curl -f http://localhost:8080/actuator/health || exit 1

# 暴露端口
EXPOSE 8080

# 启动命令
ENTRYPOINT ["sh", "-c", "java $JAVA_OPTS -jar app.jar"]
```

## 十、测试方案

### 10.1 单元测试
1. **密钥管理功能测试**
2. **加密解密功能测试**
3. **签名验证功能测试**
4. **异常处理测试

### 10.2 集成测试
1. **端到端加密流程测试**
2. **密钥分发流程测试**
3. **消息发送接收测试**
4. **多用户并发测试

### 10.3 安全测试
1. **渗透测试**：模拟各种攻击场景
2. **性能测试**：高并发下的稳定性测试
3. **压力测试**：系统极限负载测试
4. **兼容性测试**：不同客户端版本的兼容性

## 十一、总结

本方案为HuLa即时通讯系统提供了完整的端到端加密解决方案，具有以下特点：

1. **安全性**：采用业界标准的加密算法和最佳实践
2. **可扩展性**：模块化设计，易于扩展新功能
3. **高性能**：通过缓存、异步处理等优化手段
4. **可维护性**：完整的审计日志和监控体系
5. **易部署**：支持容器化和微服务架构

通过实施本方案，HuLa系统将为用户提供安全可靠的私密通讯能力，保护用户的隐私和数据安全。